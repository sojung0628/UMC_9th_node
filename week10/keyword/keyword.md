- CI/CD
    
    ### 1) 정의
    
    - **CI (Continuous Integration, 지속적 통합)**
        
        개발자들이 코드를 자주(하루에도 여러 번) 공용 저장소에 **통합(push)** 하고,
        
        그때마다 **자동으로 빌드 + 테스트**를 돌려서 문제를 빨리 찾는 방식. 
        
    - **CD (Continuous Delivery / Deployment, 지속적 전달/배포)**
        
        테스트를 통과한 코드를 **자동으로 배포 가능한 상태**까지 가져가거나,
        
        더 나아가 **실제 운영 환경까지 자동 배포**하는 프로세스
        
    
    > 한 줄로: 코드 변경 → 자동 빌드/테스트 → 자동 배포까지 이어지는 파이프라인
    > 
    
    ### 2) 특징 / 속성
    
    - **자동화**: 빌드, 테스트, 배포를 스크립트/파이프라인으로 자동화
    - **작은 단위 배포**: 작은 변경을 자주 배포 → 롤백/문제 파악이 쉬움
    - **지속적인 피드백**: 테스트 실패, 품질 이슈를 빠르게 알 수 있음
    - **DevOps 문화의 핵심**: 개발+운영 협업을 전제로 함
    
    ### 3) 장점
    
    - 버그를 **빨리 발견** → 수정 비용 감소
    - 배포가 **일상 업무**가 되어서, 릴리스 공포(“배포 공포증”) 줄어듦
    - 기능 출시 속도 ↑, 제품 품질 ↑
    
    ### 4) 단점 / 도입 시 고려사항
    
    - 파이프라인 구축 초기에 **시간/노력/인프라 비용**이 듦
    - 테스트/자동화가 허술하면 **문제를 더 빨리 퍼뜨리는 파이프라인**이 되어버릴 수도 있음
    - 조직 문화(코드 리뷰, 브랜칭 전략 등)가 같이 정비되어야 효과가 큼
- GitHub Actions
    
    ### 1) 정의
    
    - GitHub에서 제공하는 **CI/CD 및 자동화 플랫폼**.
        
        리포지토리 안에 `.github/workflows/*.yml` 파일로 **워크플로우**를 정의해서
        
        push, PR, cron 등 이벤트에 따라 **빌드/테스트/배포/기타 작업**을 자동 실행. 
        
    
    ### 2) 특징 / 속성
    
    - **GitHub에 내장**: 별도 서버 없이 GitHub-hosted runner 사용 가능 [GitHub Docs](https://docs.github.com/en/actions/get-started/continuous-integration?utm_source=chatgpt.com)
    - **이벤트 기반**: `push`, `pull_request`, `schedule(cron)`, `workflow_dispatch(수동 실행)` 등 트리거 지원
    - **Marketplace**: 수많은 오픈소스 액션들(예: `actions/checkout`, `actions/setup-node`) 조합해서 사용
    - **YAML 기반 설정**: 인프라 as code 느낌으로 파이프라인 정의
    
    ### 3) 장점
    
    - GitHub랑 **밀착 통합** → PR, Issue, Checks 탭 연동이 자연스러움
    - 소규모/개인 프로젝트는 **무료 티어**로도 시작하기 쉬움
    - 온프레/자체 서버에서 돌리고 싶으면 **self-hosted runner**도 지원
    
    ### 4) 단점 / 한계
    
    - GitHub 생태계에 의존 → GitLab/Jenkins 등과 비교해 멀티-vcs 전략에는 제약
    - 빌드 시간이 길어지면 **요금/시간 제한** 이슈
    - 고급 시나리오(모노레포 대규모 캐싱, 복잡한 매트릭스 전략)는 설계 난이도 ↑
- Reverse Proxy
    
    ### 1) 정의
    
    - 클라이언트(브라우저) 앞에 있는 게 아니라, **웹 서버 앞에 서 있는 프록시 서버**.
        
        클라이언트 요청을 먼저 받고, 내부의 실제 웹 서버들로 **대신 전달·분배**한 뒤 응답을 돌려주는 중간자. 
        
    
    ### 2) 주요 역할 / 속성
    
    - **로드 밸런싱**: 여러 백엔드 서버로 트래픽 분산
    - **캐싱**: 정적/동적 콘텐츠를 캐시해서 백엔드 부하 감소, 응답 속도 향상
    - **보안 향상**: 실제 서버 IP/구조를 숨기고, 악성 트래픽 필터링, WAF 연동 등
    - **SSL/TLS 종료(termination)**: HTTPS 복호화를 프록시에서 처리하고, 내부는 HTTP로 통신 가능
    - **URL/경로 기반 라우팅**: `/api`는 A서비스, `/static`은 B서버 등 L7 라우팅
    
    ### 3) 장점
    
    - 웹 서버 앞단에서 **성능/보안/운영 관리**를 한곳에 집중시킬 수 있음
    - 서버 교체/증설 시, 클라이언트에서 도메인/주소를 바꿀 필요가 줄어듦
    - SSL 인증서 관리, 접근 제어, 로깅 등을 중앙에서 처리
    
    ### 4) 단점 / 주의점
    
    - 프록시 자체가 단일 장애 지점(SPOF)이 될 수 있어서 이중화 필요
    - 설정이 복잡해지면 디버깅이 어려움 (특히 헤더/리다이렉트, 리버스 프록시 체인 등)
    - 잘못 구성하면 오히려 레이턴시 증가 + 보안 구멍이 될 수 있음
- HTTPS
    
    ### 1) 정의
    
    - **HTTPS (HyperText Transfer Protocol Secure)**
        
        기존 HTTP 위에 **TLS(예전 이름 SSL)** 암호화를 입힌 프로토콜.
        
        *“HTTP over TLS/SSL”* 이라고도 부름.
        
    - 브라우저와 웹 서버 사이 데이터를 **암호화·무결성·서버 인증**을 제공
    
    ### 2) 특징 / 속성
    
    - **암호화(Confidentiality)**: 제3자가 패킷을 훔쳐봐도 내용을 알 수 없음
    - **무결성(Integrity)**: 전송 중 데이터가 변조되면 탐지 가능
    - **서버 인증(Authentication)**: 브라우저가 서버 인증서(SSL/TLS cert)를 검증해서
        
        진짜 해당 도메인의 서버인지 확인
        
    - 현재는 **웹 표준** 수준: 브라우저가 HTTP 사이트에 “Not Secure” 표시하기도 함
    
    ### 3) 장점
    
    - 로그인 정보, 개인정보, 결제 정보 등 **민감한 데이터 보호**
    - SEO 측면에서도 유리 (검색 엔진이 HTTPS 사이트를 선호)
    - 사용자가 “자물쇠 아이콘” 보고 심리적 신뢰 ↑
    
    ### 4) 단점 / 고려사항
    
    - TLS 핸드셰이크/암호화로 인해 약간의 **성능 오버헤드** (요즘은 거의 무시 수준)
    - 인증서 발급/갱신/관리 필요(요즘은 Let’s Encrypt + 자동 갱신으로 많이 해결)